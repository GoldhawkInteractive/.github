name: Bump Version

on:
  workflow_call:
    inputs:
      release:
        required: true
        description: "Expects: \"major\", \"minor\", \"patch\", or a version of the form X.Y.Z"
        type: string
        default: "minor"

jobs:
  bump:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Bump version
        id: bump
        env:
          RELEASE_INPUT: ${{ inputs.release }}
        run: |
          node <<'NODE'
          const fs = require('fs');

          const releaseInputRaw = process.env.RELEASE_INPUT || 'minor';
          const releaseInput = releaseInputRaw.trim();
          const semverPattern = /^\d+\.\d+\.\d+$/;
          const allowedTypes = new Set(['major', 'minor', 'patch']);
          const normalizedInput = releaseInput.toLowerCase();
          const releaseType = allowedTypes.has(normalizedInput) ? normalizedInput : null;
          const specified = releaseType ? null : releaseInput;

          if (!releaseType && (!specified || !semverPattern.test(specified))) {
            throw new Error('Invalid release input. Expected "major", "minor", "patch", or a version of the form X.Y.Z.');
          }
          const pkgPath = 'package.json';
          const verPath = 'versioning.json';

          const readJSON = p => JSON.parse(fs.readFileSync(p, 'utf8'));
          const writeJSON = (p, obj) => fs.writeFileSync(p, JSON.stringify(obj, null, 4) + '\n');

          const getCurrentVersion = () => {
            if (fs.existsSync(verPath)) {
              return readJSON(verPath).VERSION;
            }
            if (fs.existsSync(pkgPath)) {
              return readJSON(pkgPath).version;
            }
            throw new Error('No version found');
          };

          const inc = (version, type) => {
            const parts = version.split('.').map(Number);
            if (type === 'major') return `${parts[0]+1}.0.0`;
            if (type === 'minor') return `${parts[0]}.${parts[1]+1}.0`;
            return `${parts[0]}.${parts[1]}.${parts[2]+1}`;
          };

          const current = getCurrentVersion();
          const newVersion = specified || inc(current, releaseType);

          if (fs.existsSync(verPath)) {
            const data = readJSON(verPath);
            data.VERSION = newVersion;
            writeJSON(verPath, data);
          }

          if (fs.existsSync(pkgPath)) {
            const pkg = readJSON(pkgPath);
            pkg.version = newVersion;
            if (pkg.dependencies) {
              Object.keys(pkg.dependencies).forEach(dep => {
                pkg.dependencies[dep] = newVersion;
              });
            }
            writeJSON(pkgPath, pkg);
          }

          fs.appendFileSync(process.env.GITHUB_OUTPUT, `version=${newVersion}\n`);
          NODE
      - name: Find Trello card
        id: trello
        env:
          TRELLO_KEY: ${{ secrets.TRELLO_KEY }}
          TRELLO_TOKEN: ${{ secrets.TRELLO_TOKEN }}
          TRELLO_BOARD_ID: ${{ secrets.TRELLO_BOARD_ID }}
          VERSION: ${{ steps.bump.outputs.version }}
        run: |
          node <<'NODE'
          const fs = require('fs');

          const { TRELLO_KEY, TRELLO_TOKEN, TRELLO_BOARD_ID, VERSION } = process.env;

          if (!TRELLO_KEY || !TRELLO_TOKEN || !TRELLO_BOARD_ID) {
            throw new Error('Missing Trello configuration (TRELLO_KEY, TRELLO_TOKEN, TRELLO_BOARD_ID).');
          }

          const cardName = `Create Release Branches (${VERSION})`;
          const cardsUrl = new URL(`https://api.trello.com/1/boards/${TRELLO_BOARD_ID}/cards/open`);
          cardsUrl.searchParams.set('key', TRELLO_KEY);
          cardsUrl.searchParams.set('token', TRELLO_TOKEN);
          cardsUrl.searchParams.set('fields', 'id,name,idList');

          const appendOutput = (card) => {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `card-id=${card.id}\n`);
          };

          const trelloFetch = async (input, init) => {
            const response = await fetch(input, init);
            if (!response.ok) {
              const text = await response.text();
              throw new Error(`Trello request failed: ${response.status} ${text}`);
            }
            return response;
          };

          (async () => {
            const listsUrl = new URL(`https://api.trello.com/1/boards/${TRELLO_BOARD_ID}/lists`);
            listsUrl.searchParams.set('key', TRELLO_KEY);
            listsUrl.searchParams.set('token', TRELLO_TOKEN);
            listsUrl.searchParams.set('filter', 'open');

            const listsResponse = await trelloFetch(listsUrl);
            const lists = await listsResponse.json();
            const completeListPrefix = `Complete (${VERSION})`;
            const completeLists = lists.filter(list => list && !list.closed && typeof list.name === 'string' && list.name.startsWith(completeListPrefix));
            const openLists = lists.filter(list => list && !list.closed);
            const targetList = completeLists[0] || openLists[0];

            if (!targetList) {
              throw new Error(`Unable to locate an open list on board ${TRELLO_BOARD_ID} to create card "${cardName}".`);
            }

            const cardsResponse = await trelloFetch(cardsUrl);
            const cards = await cardsResponse.json();
            const validListIds = completeLists.length ? new Set(completeLists.map(list => list.id)) : new Set();
            const match = cards.find(card => {
              if (!card || card.name !== cardName) {
                return false;
              }
              return validListIds.size === 0 || validListIds.has(card.idList);
            });

            if (match) {
              appendOutput(match);
              return;
            }

            const createUrl = new URL('https://api.trello.com/1/cards');
            createUrl.searchParams.set('key', TRELLO_KEY);
            createUrl.searchParams.set('token', TRELLO_TOKEN);
            createUrl.searchParams.set('idList', targetList.id);
            createUrl.searchParams.set('name', cardName);
            createUrl.searchParams.set('pos', 'top');

            const createResponse = await trelloFetch(createUrl, { method: 'POST' });
            const createdCard = await createResponse.json();

            appendOutput(createdCard);
          })().catch(error => {
            console.error(error);
            process.exit(1);
          });
          NODE
      - name: Configure Git
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
      - name: Commit changes
        run: |
          git add -A
          git commit -m "version: bump {#close ${TRELLO_CARD_ID} ${VERSION}}" || echo "No changes to commit"
        env:
          TRELLO_CARD_ID: ${{ steps.trello.outputs.card-id }}
          VERSION: ${{ steps.bump.outputs.version }}
      - name: Push changes
        if: success()
        run: git push
